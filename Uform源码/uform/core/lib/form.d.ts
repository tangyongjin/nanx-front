import { Field } from './field';
import { Subject } from 'rxjs/internal/Subject';
import { IFormOptions, IFieldOptions, IFieldState, IField, IFormPathMatcher, IFormState, Path } from '@uform/types';
declare type Editable = boolean | ((name: string) => boolean);
export declare class Form {
    editable: Editable;
    private options;
    private publisher;
    private state;
    private fields;
    private subscribes;
    private updateQueue;
    private updateBuffer;
    private schema;
    private initialized;
    private destructed;
    private fieldSize;
    private syncUpdateMode;
    private updateRafId;
    private rafValidateId;
    private batchUpdateField;
    private validating;
    private traverse;
    constructor(opts: IFormOptions);
    changeValues(values: any): void;
    changeEditable(editable: Editable): void;
    isDirtyValues(values: any): boolean;
    setFieldState: (path: string | number | (string | number)[] | IFormPathMatcher, callback: (fieldState: IFieldState) => void) => Promise<void>;
    getFieldState(path: Path | IFormPathMatcher, callback: (fieldState: IFieldState) => void): void;
    getFieldState(path: Path | IFormPathMatcher): IFieldState;
    getFormState(callback: (formState: IFormState) => void): void;
    getFormState(): IFormState;
    setFormState: (callback: (formState: IFormState<any>) => void) => Promise<any>;
    registerField(name: string, options: IFieldOptions): IField<any>;
    setIn(name: string, value: any): void;
    setInitialValueIn(name: string, value: any): void;
    setValue(name: string, value: any): void;
    setErrors(name: string, errors: string[] | string, ...args: string[]): void;
    updateChildrenValue(parent: Field): void;
    updateChildrenInitalValue(parent: Field): void;
    updateFieldInitialValue(): Promise<any>;
    updateFieldsValue(validate?: boolean): Promise<any>;
    updateChildrenVisible(parent: Field, visible?: boolean): void;
    updateChildrenDisplay(parent: Field, display?: boolean): void;
    getInitialValue(name: string, path?: Path): any;
    getValue(name?: string, copy?: boolean): any;
    deleteIn(name: string): void;
    deleteInitialValues(name: string): void;
    reset(forceClear?: boolean, validate?: boolean): void;
    publishState(): {
        values: any;
        valid: any;
        invalid: any;
        errors: any;
        pristine: any;
        dirty: any;
        initialValues: any;
    };
    formNotify(fieldState?: IFieldState): {
        values: any;
        valid: any;
        invalid: any;
        errors: any;
        pristine: any;
        dirty: any;
        initialValues: any;
    };
    validate(): Promise<IFormState>;
    submit(): Promise<IFormState<any>>;
    subscribe(callback: (payload: any) => void): () => any;
    destructor(): void;
    dispatchEffect: (eventName: string, ...args: any[]) => void;
    syncUpdate(fn: () => void): void;
    initialize({ initialValues, values }: {
        initialValues?: any;
        values?: any;
    }): void;
    selectEffect: (eventName: string, eventFilter: string | IFormPathMatcher) => Subject<any>;
    private initializeEffects;
    private checkState;
    private asyncUpdate;
    private updateFieldStateFromQueue;
    private updateFieldStateFromBuffer;
    private internalValidate;
}
export {};
